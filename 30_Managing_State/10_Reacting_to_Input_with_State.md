### Интерактивность в react

- описываются состояния приложения
- состояние переключаются в ответ на действия пользователей

Это декларативный подход.

---

### Императивная обработка формы 

<div style="display: flex;">
    <div style="flex: 1;">
    <img src="3_1_form.png"/>
    </div>
    <div style="flex: 5;"><small><ul>
        <li>Когда вы вводите что-то в форму, кнопка "Отправить" становится активной.</li>
        <li>Когда вы нажимаете кнопку "Отправить", и форма, и кнопка отключаются, и появляется спиннер.</li>
        <li>Если сетевой запрос прошел успешно, форма спрячется, и появится сообщение "Спасибо".</li>
        <li>Если сетевой запрос не удался, появляется сообщение об ошибке, и форма снова становится открытой.</li>
    </ul></small><div>
<div>

---

### Императивная обработка формы 

Пример: ```npm run dev public\3_1```

Основная проблема: экспоненциальный рост сложности

---

### Декларативный интерфейс

<div style="display: flex;">
    <div style="flex: 2;">
    <img src="i_imperative-ui-programming.png"/>
    </div>
    <div style="flex: 2;">
    <img src="i_declarative-ui-programming.png"/>
    <div>
<div>

---

### План реализации UI в react

1. Определите различные визуальные состояния вашего компонента
1. Определите, что вызывает изменение состояния.
1. Представьте состояние в памяти с помощью useState.
1. Удалите любые несущественные переменные состояния
1. Подключите обработчики событий для установки состояния

---

### 1 Визуальные состояния компонента 

- **Пусто (Empty)**: Форма имеет отключенную кнопку "Отправить".
- **Набор текста (Typing)**: Форма имеет включенную кнопку "Отправить".
- **Отправка (Submitting)**: Форма полностью отключена. Отображается спиннер.
- **Успех (Success)**: Вместо формы отображается сообщение "Спасибо".
- **Ошибка (Error)**: То же самое, что и состояние типирования, но с дополнительным сообщением об ошибке. ```3/1/App2```

---

### 2 Определите, что вызывает изменение состояния

![](responding_to_input_flow.webp)

---

### 3 Представьте состояние в памяти с помощью useState

```
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

---

### 4 Удалите любые несущественные переменные состояния

- Имеются ли коллизии (```isTyping``` и ```isSubmitting```)
- Дублируется ли информация (```isEmpty```?)

```
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
// 'typing', 'submitting', or 'success'
const [status, setStatus] = useState('typing');
```

---

### 5 Подключите обработчики событий для установки состояния

```3/1/App3```

---

### Резюме

- <small>Декларативное программирование означает описание пользовательского интерфейса для каждого визуального состояния, а не микроменеджмент пользовательского интерфейса (императивное программирование).</small>
- <small>При разработке компонента:</small>
    - <small>Определите все его визуальные состояния.</small>
    - <small>Определите человеческие и компьютерные триггеры для изменения состояния.</small>
    - <small>Смоделируйте состояние с помощью useState.</small>
    - <small>Удалите несущественные состояния, чтобы избежать ошибок и парадоксов.</small>
    - <small>Подключите обработчики событий для установки состояния.</small>