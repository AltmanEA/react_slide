### Интерактивность в react

- описываются состояния приложения
- состояние переключаются в ответ на действия пользователей

Это декларативный подход.

---

### Императивная обработка формы 

[Пример](ex1)

<div style="display: flex;">
    <div style="flex: 1;">
    <img src="3_1_form.png"/>
    </div>
    <div style="flex: 5;"><small><ul>
        <li>Когда вы вводите что-то в форму, кнопка "Отправить" становится активной.</li>
        <li>Когда вы нажимаете кнопку "Отправить", и форма, и кнопка отключаются, и появляется спиннер.</li>
        <li>Если сетевой запрос прошел успешно, форма спрячется, и появится сообщение "Спасибо".</li>
        <li>Если сетевой запрос не удался, появляется сообщение об ошибке, и форма снова становится открытой.</li>
    </ul></small><div>
<div>
---

### Интерактивный vs Декларативный интерфейс

<div style="display: flex;">
    <div style="flex: 2;">
    <img src="i_imperative-ui-programming.png"/>
    </div>
    <div style="flex: 2;">
    <img src="i_declarative-ui-programming.png"/>
    <div>
<div>

---

### План реализации UI в react

1. Определите различные визуальные состояния вашего компонента
1. Определите, что вызывает изменение состояния.
1. Представьте состояние в памяти с помощью useState.
1. Удалите любые несущественные переменные состояния
1. Подключите обработчики событий для установки состояния

---

### 1 Визуальные состояния компонента 

- <small>**Пусто (Empty)**: Форма имеет отключенную кнопку "Отправить".</small>
- <small>**Набор текста (Typing)**: Форма имеет включенную кнопку "Отправить".</small>
- <small>**Отправка (Submitting)**: Форма полностью отключена. Отображается спиннер.</small>
- <small>**Успех (Success)**: Вместо формы отображается сообщение "Спасибо".</small>
- <small>**Ошибка (Error)**: То же самое, что и состояние типирования, но с дополнительным сообщением об ошибке. ```3/1/App2```</small>

[Пример](ex2)

---

### 2 Определите, что вызывает изменение состояния

![](responding_to_input_flow.webp)

---

### 3 Представьте состояние в памяти с помощью useState

```
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

---

### 4 Удалите любые несущественные переменные состояния

- Имеются ли коллизии (```isTyping``` и ```isSubmitting```)
- Дублируется ли информация (```isEmpty```?)

```
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
// 'typing', 'submitting', or 'success'
const [status, setStatus] = useState('typing');
```

---

### 5 Подключите обработчики событий для установки состояния

[Пример](ex3)

---

### Резюме

- <small>Декларативное программирование означает описание пользовательского интерфейса для каждого визуального состояния, а не микроменеджмент пользовательского интерфейса (императивное программирование).</small>
- <small>При разработке компонента:</small>
    - <small>Определите все его визуальные состояния.</small>
    - <small>Определите человеческие и компьютерные триггеры для изменения состояния.</small>
    - <small>Смоделируйте состояние с помощью useState.</small>
    - <small>Удалите несущественные состояния, чтобы избежать ошибок и парадоксов.</small>
    - <small>Подключите обработчики событий для установки состояния.</small>